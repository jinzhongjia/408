* 存储系统

分为主存储器、辅助存储器、高速缓冲存储器。

按存取方式还可分为：随机存储器、制度存储器、串行访问存储器

还可分为：（非）易失性存储器、（非）破坏性读出（DRAM）

** 性能指标

存储容量 = 存储字长 X 字长

单位成本：每位价格 = 总成本 / 总容量

存储速度：数据传输率 = 数据的宽度 / 存取周期。

存取时间：指从启动一次存储器操作到完成该存储器操作之间所需要的时间，分为读出时间和写入时间。

存取周期：又称读写周期或访问周期。指存储器进行完整读写操作所需要的全部时间，即连续两次独立访问存储器操作之间所需的最小时间间隔。

主存带宽：又称数据传输率，表示每秒从主存进出的信息的最大数量。

存取周期通常大于存取时间，因为读写操作之后会有一段恢复内部状态的复原时间。

** 多级层次的存储系统

三层，cache、主存、辅存

主存和 cache 之间的数据调用是由硬件自动完成的，对于程序员来说是透明的。

主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员来说是透明的。

** 主存储器

主要是 SRAM 和 DRAM 两种，其中 DRAM 属于破坏性读出，需要复原。

其中主存使用的是 SRAM，cache 使用的是 DRAM。

*** DRAM

DRAM 需要进行刷新，分为集中刷新、分散刷新、异步刷新（刷新周期 / 行数）。

读写周期：

  读操作：先送行，再送列，其中 WE 是高电平
  写操作：先送行，再送列，其中 WE 是低电平
  
*** SRAM 和 DRAM 比较

|            | SRAM     | DRAM     |
| 存储信息   | 触发器   | 电容     |
| 破坏性读出 | 非       | 是       |
| 需要刷新   | 不需要   | 需要     |
| 送行列地址 | 同时送   | 先行后列 |
| 运行速度   | 快       | 慢       |
| 集成度     | 低       | 高       |
| 存储成本   | 高       | 低       |
| 主要用途   | 高速缓存 | 主机内存 |

*** 存储器内部结构

- 存储体
- 地址译码器
- I/O控制电路
- 片选控制信号
- 读/写控制信号

*** 只读存储器

也叫 ROM，相对 RAM 来说，结构简单，位密度比可读写存储器高，具有非易失性，可靠性高

**** 类型

- 掩模式只读存储器 *MROM*
  生产时刻录，不可改变，集成度高，便宜
- 一次性可编程只读存储器 *PROM*
  通过特定设备写入，只能写入一次，后面就无法更改
- 可擦除可编程只读存储器 *EPROM*
  可读可写，但不能代替 RAM，寿命短并且写入时间长
- Flash 存储器
  可保存信息，还支持快速擦除和重写，集成度高，较好用
- 固态硬盘 SSD
  基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元组成。缺点是贵，优点很多。
  
 #+begin_quote
 DRAM 存储容量大，地址位数多，为了减少芯片的地址引脚数，通常采用地址引脚服用技术，行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半。
 #+end_quote

*** 多模块存储器

属于空间并行技术，多个结构完全相同的存储模块并行工作来提高存储器的吞吐率。

**** 单体多字存储器

只有一个存储体，每个存储单元存储 m 个字，总线宽度也是 m 个字，一次并行读出 m 个字，地址必须排序排列并处于同一存储单元。

一次性取出 m 条指令，然后逐条送至 CPU 执行，也就是 $1/m$ 存取周期，CPU 向主存取一条指令。

很明显提高了单体存储器的工作速度。

**** 多体并行存储器

***** 高位交叉编址

顺序方式，高位表示体号，低位表示体内地址。

顺序访问存储块，无法并行存取，存取仍然是串行的，不会提高存储器的吞吐率。

***** 低位交叉编址

交叉方式，低位表示体号，高位表示体内地址。

采用流水线的方式并行读取，提高存储器的宽带。

设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为 人，为实现流水线方式存取，存储器交叉模块数应大于等于 $m = T/r$ ，这样是为了保证该模块在经过 $M * r$ 的时间后再次启动该模块时，其上次的存取操作已经完成了，。

这样连续存取 m 个字的时间就是 $T + (m - 1) * r$

** 主存储器与 CPU 连接

*** 连接原理

- 主存储器通过数据总线、地址总线和控制总线与 CPU 连接
- 数据总线的位数与工作频率的乘积正比于数据传输率
- 地址总线的位数决定了可寻址的最大内存空间
- 控制总线指出总线周期的类型和本次输入/输出操作完成的时刻

*** 主存容量扩展

三种方案：位扩展、字扩展、字位同时扩展

**** 位扩展

- 地址线、片选线和读写控制线并联
- 数据线依次连接CPU数据线的一位

**** 字扩展

- 数据线、读写控制线和地址线并联
- 使用PU剩下的地址线连接片选线，选择当前读/写的芯片
  - 线选法：直接将地址线与片选线连接，一根地址线对应一根片选线
  - 译码器片选法：使用译码器将连接CPU地址线与片选线
| 线选法               | 译码器片选法              |
| n条线 -> n个选片信号 | n条线 -> $2^n$ 个片选信号 |
| 电路简单             | 电路复杂                  |
| 地址空间不连续       | 地址空间可连续            |

#+begin_quote
线选法和译码器片选法的主要区别在于它们如何选择存储单元。

线选法：在这种方法中，系统使用地址线直接选择存储单元。每个存储单元都有一个特定的地址，当地址线发送一个特定的地址时，只有对应的存储单元会被选中。如果存储单元的地址不连续（例如，某些地址被保留或未使用），那么在地址空间中就会出现不连续的情况。

译码器片选法：在这种方法中，系统使用一个译码器来解码地址信号。译码器会将输入的地址信号转换为一个片选信号，选择特定的存储单元。由于译码器可以处理多个地址信号并生成多个输出信号，因此可以更灵活地选择存储单元，允许地址的连续性。

总结来说，线选法直接依赖于地址线，可能导致不连续，而译码器片选法通过译码器的灵活性，可以实现地址的连续选择。
#+end_quote

**** 字位同时扩展

[[file:image/image_20240901_200250.png]]

** 外部存储器

*** 磁盘存储器

组成： 磁盘驱动器、磁盘控制器、盘片

存储区域：一块硬盘含有若干记录面，每个记录面划分为若干磁道，，每条磁道又划分为若干扇区，扇区是磁盘读写的最小单位，积磁盘按块存取。

磁盘性能指标：记录密度、磁盘容量、平均存取时间、数据传输率

磁盘地址

*** 磁盘阵列

RAID0、RAID1、RAID2、RAID3、RAID4、RAID5.

*** 固态硬盘

基于闪存技术，和 U 盘无本质区别，仅仅是容量更大、存取性能更好。

** 高速缓冲存储器

依托于程序访问的局部性原理：
  - 时间局部性，一条指令一旦被执行，不久的将来可能被再次执行
  - 空间局部性，一个存储单元呗访问，则其临近的存储单元也将被访
本质是利用局部性原理，将程序中正在使用的部分数据放在一个高速的、容量较小的 cache 中，让 CPU 的仿存操作大多数是针对 cache 进行，从而提高程序的执行速度。

** cache 工作原理

基于局部性原理，可以把 CPU 目前访问的地址周围的部分数据放到 Cache 中。

将主存与Cache分为同样大小的块，主存和 Cache 之间以块为单位进行数据交换。系统访问主存时，会将这一块的内容同时复制到 Cache 中。

** cache 性能分析

命中率 H：CPU 欲访问的信息已在 Cache 中的比率

实际上有两种访存方案，一种是串行访问，即先访问 cache，未命中再访问内存，另一种是并行访问，即同时访问 cache 和内存。

*但考试实际考察串行访问！*

** cache 和主存的映射方式

cache 需要设置有效位，表明此块是否有效

cache 还需要设置标记，与主存块号相等，表示存储的主存块。

*** 直接映射

每个主存块只能放在特定的位置
主存块在Cache中的位置 = 主存块号 % Cache总块数

[[file:image/image_20240901_200441.png]]

实际结构为：

| 标记 | cache 行号 | 块内地址 |

优点：
对于任意一个地址，只需要对比一个标记，速度最快。

缺点：
cache 空间利用率低，命中率低

*** 全相联映射

主存块可以存放在Cache的任何位置

[[file:image/image_20240901_200616.png]]

实际结构为：

| 标记 | 块内地址 |

优点：
cache 存储空间利用充分，命中率高

缺点：
查找标记最慢，可能需要对比所有行的标记

*** 组相联映射

将Cache块分组，每个主存块只能存放到特定的分组中。当分组中有空位时，就将该主存块中的内容存入

主存块在Cache中的位置 = 主存块号 % Cache 分组数

[[file:image/image_20240901_201117.png]]

路数代表每组几个 cache 行，路数越大，也就是每组 cache 行的数量越大，发生块冲突的数量越低，但是相联比较电路也越复杂。

选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。

实际结构：

| 标记 | 组号 | 块内地址 |

优缺点：两种方案的折中，整体效果最好

** cache 替换算法

直接映射无需考虑替换算法，而全相联和组相联需要考虑。

常见算法：随机算法（RAND）、先进先出算法（FIFO）、近期最少使用算法（LRU）、最近不经常使用算法（LFU）。

*** 随机算法（RAND）

优点：实现简单

缺点：没有考虑局部性原理，命中率低

*** 先进先出算法（FIFO）

若Cache已满，则替换最先被调入Cache的块。

从硬件层面，可以在将主存块存入Cache块时按照Cache块序号顺序存入，则替换时也仅需要顺序替换即可替换最先存入的。

优点：实现简单

缺点：没有考虑到局部性原理，会出现抖动现象（块被频繁的换入换出）

*** 近期最少使用算法（LRU）

为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了。当Cache满后替换计数器最大的。

#+begin_quote
从题目的角度，仅需要向前数n个访问的块，则第n+1个块就是要替换的。（n为Cache块数）
#+end_quote

*算法逻辑* ：

- 命中时
  - 所命中的行的计数器清零
  - 计数器值比被命中的块的值低的块，计数器加1
  - 其余不变
- 未命中
  - 还有空闲行时
    - 新装入的行的计数器置0
    - 其余非空闲行全加1
  - 无空闲行时
    - 计数值最大的行的信息块被淘汰
    - 新装行的块的计数器置0
    - 其余全加1

优点：遵循了局部性原理，cache 命中率高

缺点：若被频繁访问的 *主存块数量* > *Cache行的数量* ，则有可能发生抖动
      
*** 最近不经常使用算法（LFU）

为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块被访问过几次。

每被访问一次，计数器 +1 当 Cache 满后替换计数器最小的。

缺点：计数器可能需要很大的长度，曾经被经常访问的主存块未必会在未来用到

实际运行效率不如 LRU。

** cache 写策略

cache 需要和主存保持一致，因为 cache 相当于主存的副本。

通常来说，有两种方案，一种是回写法，另一种是全写法

*** 回写法

当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存。

对每一个 Cache 行增加一个脏位，标记该行是否被修改过。只有被修改过的块才进行写回操作。

优点：减少了访存次数

缺点：存在数据不一致的隐患

*** 全写法

写命中时，需要同时写入 cache 和主存，等到替换时，新块直接覆盖即可，使用 SRAM。

优点：能保证数据的一致性

缺点：访存次数增加，速度变慢，当写操作较多时，写缓冲队列会饱和

*** 写不命中

**** 写分配法

当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。

通常搭配写回法使用。

**** 非写分配法

当CPU对Cache写不命中时只写入主存，不调入Cache。只有读未命中时才调入Cache。

搭配全写法使用。
