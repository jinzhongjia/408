* 指令系统

指令是指计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。

指令系统是指令集体系结构（ISA）中最核心的部分。

ISA 完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应该熟悉的。

ISA 规定的内容主要包括：指令格式、数据类型及格式、操作数的存放方式、程序可访问的寄存器个数、位数和编号、存储空间的大小和编制方式、寻址方式、指令执行过程的控制方式等。

** 指令基本格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。

一条指令通常包括操作码字段和地址码字段：

| 操作码字段 | 地址码字段 |

其中，操作码定义了要进行什么操作，而地址码定义了被操作信息的地址

** 按地址码数量分类

*** 零地址指令

不需要操作数的指令，例如空操作指令、停机指令、关中断指令。

堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶

*** 一地址指令

**** 单操作数，加一、减一、取反、求补

指令含义： $OP(A)=A$

三次访存操作：取指、读、写

**** 隐含约定目的地址的双操作数指令

另一个操作数一般由ACC提供，结果也存放在ACC中。

指令含义：$(ACC)OP(A_{1})->ACC$

两次访存：取指、
读

*** 二地址指令

需要两个操作数的算术运算、逻辑运算相关指令

指令含义：$(A_{1})OP(A_{2})->A_{1}$

四次访存：取指、读 $A_{1}$ 、读 $A_{2}$ 、-> 写 $A_{1}$

*** 三地址指令

需要两个操作数的算术运算、逻辑运算相关指令

指令含义：$(A_{1})OP(A_{2})->A_{1}$

四次访存：取指、读 $A_{1}$ 、读 $A_{2}$ 、-> 写 $A_{1}$

*** 四地址指令

与三地址指令相同，但是 $A_{4}$ 存放下一条要执行的指令的地址。

#+begin_quote
正常情况下，执行完毕后，会自动将 PC 增加 1，但是四地址指令是将 PC 的值设置为 $A_{4}$
#+end_quote

** 一些概念

指令字长：一条指令的总长度

机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数（通常与ALU直接相关）

存储字长：一个存储单元中的二进制代码位数（通常与 MDR 位数相同）

半字长指令、单字长指令、双字长指令：指令长度是机器字长的多少倍，指令长度影响取指令的时间。

定长指令字结构：指令系统中所有指令的长度都相等。

变长指令字结构：指令系统中各种指令的长度不等。

#+begin_quote
*定长操作码* ：指令系统中所有指令的操作码长度都相同

- 译码电路设计简单，灵活性较差

*可变长操作码* ：指令系统中各指令的操作码长度可变

- 译码电路设计复杂，灵活性高
#+end_quote

** 指令操作类型

数据传送：LOAD、STORE

算术和逻辑运算

移位运算

转移操作：（无）条件转移、调用、返回、陷阱。

I/O操作

** 扩展操作码指令

#+ATTR_HTML: :width 900px
[[file:image/image_20240827_155246.png]]

** 指令寻址方式

*** 指令寻址

- 顺序寻址
    通过 PC 寄存器实现，$(PC)+1->PC$，并不是普通的加一操作，增加的一个指令字长的大小
- 跳跃寻址

*** 数据寻址

是指如何在指令中表示一个操作数的地址，如何用这种表示的到操作数或怎样计算出操作数的地址。

[[file:image/image_20240827_162734.png]]

**** 隐含寻址

不明显给出操作数的地址，一般是用 ACC（累加器）作为操作数地址来用。

**** 立即数寻址

指令的地址字段直接表示操作数本身，使用补码表示。
优点是不用访存，缺点是范围受到地址数限制

**** 直接寻址

指令字中的形式地址就是真实地址，直接访问即可。

优点：
  - 实现简单
  - 只访存一次

缺点：
  - 由于形式地址长度优先，寻址范围优先
  - 操作数地址难以修改
    
**** 间接寻址

形式地址指向一个主存单元，在该主存单元内存放着操作数的真实地址。

三次访存：取指令获得形式地址，通过形式地址发现真实地址，再通过真实地址取得真实值

#+begin_quote
当然，在此基础上，可以继续套娃，进行多次间接寻址。
#+end_quote
优点：
  - 扩大寻址范围
  - 便于编程
缺点：
  - 需要多次访存

**** 寄存器寻址

地址码部分给的是寄存器号（标示符），寄存器中存放的是真实地址。

两次访存：取指令、执行指令（访问真实地址）

优点：
  - 比间接寻址更快
缺点：
  - 寄存器属于稀缺资源

**** 寄存器间接寻址

*寄存器寻址* + **间接寻址* 组合。

**** 相对寻址

通过 PC 寄存器与形式地址（存储的是相对于 PC 的地址）相加，得到真实地址。

形式地址中的值一般是补码形式，可正可负。

优点：
  - 循环时不用更改跳跃指令的地址码，直接动 PC 就行
  - 多道程序设计中，程序可能在内存中浮动，需要用到
     
**** 基址寻址

类似相对寻址，不过使用的是基址寄存器（BR），当然也可以用通用寄存器

#+begin_quote
基址是指在计算机内存中，用作寻址的起始地址。它通常存储在基址寄存器中，结合偏移量来计算最终的内存地址。基址使得程序可以灵活地访问内存中的数据，尤其是在处理数组和动态内存分配时。

在程序运行开始前，CPU 会将 PCB 中的程序起始地址存放进 BR 中。

用户无法修改 BR 的内容，只能指定某个寄存器充当 BR。
#+end_quote

**** 变址寻址

类似相对寻址，不过使用的是变址寄存器（IX），也可以使用通用寄存器。

变址和基址的区别：基址寻址是基址不变，形式地址变化，而变址寻址是形式地址不变，变址寄存器内的值改变

优点：适合循环程序，例如数组问题

**** 堆栈寻址

堆栈是存储器中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址使用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。

堆栈可分为硬堆栈与软堆栈两种。

寄存器堆栈又被称为硬堆栈，成本高不适合做大容量堆栈。

从主存划出一块区域来用作堆栈更加划算，也被称为软堆栈。

堆栈可用于函数调用时保存当前函数的相关信息，例如标志寄存器。

**** 总结

寻址方式、有效地址及访存次数：

| 寻址方式           | 有效地址      | 访存次数 |
|--------------------+---------------+----------|
| 隐含寻址           | 程序指定      |        0 |
| 立即寻址           | A 就是操作数  |        0 |
| 直接寻址           | EA = A        |        1 |
| 一次间接寻址       | EA = (A)      |        2 |
| 寄存器寻址         | EA = R_{i}       |        0 |
| 寄存器间接一次寻址 | EA = (R_{i})     |        1 |
| 相对寻址           | EA = (PC) + A |        1 |
| 基址寻址           | EA = (BR) + A |        1 |
| 变址寻址           | EA = (IX) + A |        1 |

** CISC 和 RISC

计算机目前向着两个完全不同的方向发展：

  - 试图增强原有指令的功能，设置更加复杂的新指令实现软件功能的硬化，也就是复杂指令系统计算机（CISC），典型的是 x86 架构
    
  - 尝试减少指令种类和简化指令功能，提高指令的执行速度，也就是精简指令系统计算机（RISC），典型的是 ARM、MIPS 架构

[[file:image/image_20240827_201624.png]]

** 一些汇编代码

需要少量汇编知识，嗯，我自己的知识储备已经够用
